---
title: CF ans
date: 2026-02-15 15:00:00 +0800
categories: ["ACM"]
---
# CODEFORCES
## NEUQ_ACM
### PROBLEM_T

### 分析：
- 初始A和B 为($2^k$,$2^k$)
- A和B可以将自己减半，加给对方，称为一次操作
- 给定目标结果（x,2^(k+1)-x),求解最少操作步数使得初试ab变成目标结果
- 很自然的一个思路就是bfs，把每一步操作所能到达的情况保存下来，一层一层往下推，~~但是这种方法我不会写代码~~
### 在草稿纸上画一画过后，有如下思路：
![](https://cdn.luogu.com.cn/upload/image_hosting/wjq79htv.png)
```cpp
#include <bits/stdc++.h>
using namespace std;
int t;
int main()
{
    //freopen("t.out", "w", stdout);
    cin >> t;
    while (t--)
    {
        long long k, x, ans[121];
        for (int i = 1; i <= 120; i++)
            ans[i] = 0;
        cin >> k >> x;
        if ((int)pow(2, k) == x)
            cout << 0 << endl
                 << endl;
        else
        {
            long long a, b, cnt = 0, sum = (long long)pow(2, k + 1);
            a = x, b = sum - x;
            while (a != sum / 2)
            {
                if (a < b)
                    a *= 2, b = sum - a, ans[++cnt] = 1;
                else
                    b *= 2, a = sum - b, ans[++cnt] = 2;
            }
            cout << cnt<<endl;
            for (int i = cnt; i >= 1;i--)
                cout << ans[i] << " ";
            cout << endl;
        }
    }
    return 0;
}
```